Clojure 
Clojure — Lisp'ообразный язык общего назначения, разработанный для Java Virtual Machine (JVM). Автором языка является Rich Hickey, который несколько лет разрабатывал язык в одиночку вплоть до выпуска первой публичной версии в 2007-м году. В настоящее время, стабильной версией является версия 1.2, выпущенная в августе 2010-го года.
В отличие от других реализаций Lisp'а и Scheme для виртуальной машины Java, таких как ABCL, Kawa и т.д., Clojure не совместим на 100 процентов ни с Common Lisp, ни с Scheme, но позаимствовал многие идеи из этих языков, добавив новые вещи, такие как неизменяемость данных, конкурентное выполнение кода и т.п. 
Несмотря на то, что Clojure — молодой язык программирования, достаточно много людей используют его в своих проектах, в том числе и коммерческих, например, FlightCaster, который использует Clojure при обработке большого количества данных, решая задачи Machine Learning в распределенной среде. Существуют и другие фирмы (например, Sonian, Runa, Emendio), использующие этот язык в своей работе. 
Clojure сочетает в себе много интересных возможностей: доступность, горячая замена кода, разработка многопоточных программ. Clojure будет особенно интересен программистам, пишущим на Java или смотрящим в сторону функциональных языков.
Преимущества
Clojure обладает рядом преимуществ перед другими языками программирования:
· язык ориентирован на работу с данными. Данные вынесены в основу концепции Clojure. У него есть все средства для работы с ними, а также удобная библиотека. Язык заменяет данными классы, иерархии, объекты, что позволяет разработчику легко работать и писать на Clojure;
· Clojure – очень динамический язык программирования. У него есть возможность запускать команды в консоли и тут же просматривать результат, не затрачивая лишнего времени. Также есть возможность горячей подмены кода, позволяющая не инициализировать программу заново при каждом изменении в коде;
· язык очень компактен. Например, размер кода, написанного на Clojure, будет от 3 до 10 раз меньше, чем у Java.

Отличия от Lisp
Несмотря на схожесть синтаксиса, Clojure отличается и от Common Lisp, и от Scheme. Некоторые отличия обусловлены тем, что язык разработан для платформы JVM, что накладывает некоторые ограничения на реализацию. Например, JVM не поддерживает оптимизацию хвостовых вызовов (tail call optimization, TCO), поэтому в язык были введены явные операторы loop и recur. Также важными определяющими факторами JVM-платформы являются:
•	boxed integers — нет поддержки полного набора типов чисел (numeric tower), которые есть в Scheme и Common Lisp;
•	система исключений как в Java (в Common Lisp используется сигнальный протокол);
•	используется соглашение о вызовах как в Java.

Из явных отличий от Common Lisp можно отметить следующие:
•	идентификаторы в Clojure регистрозависимы (case-sensitive);
•	большая часть данных — неизменяемая;
•	пользователь не может изменять синтаксис языка путем ввода собственных макросов в процедуре чтения кода (read macros);
•	введен специальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и т.д.;
•	существует возможность связывания метаданных с переменными и функциями;
•	можно реализовать функции с одним именем и разным набором аргументов;
•	многие привычные вещи, такие как let, по синтаксису отличаются от их аналогов в Common Lisp и Scheme (при этом используется меньше скобок), например, let связывает данные последовательно, аналогично let* в Scheme;
•	вместо функций car и cdr используются функции first и rest;
•	nil не равен пустому списку или другому набору данных (коллекции) — он всего лишь означает отсутствующее значение (аналог null в Java);

Основные типы данных
Данные в Clojure можно разделить на две большие группы: базовые типы данных — числа, строки и т.д., и последовательности (коллекции), к которым относятся списки, векторы, отображения и множества. Пользователь может определять свои структуры данных с помощью defstruct, но они являются частным случаем отображений и введены для обеспечения более эффективной работы со сложными данными.
Все типы данных имеют общий набор характеристик: данные неизменяемы и реализуют операцию "равенство" (equality).
Базовые типы данных
К базовым типам данных Clojure относятся следующие:
логические значения
в языке определено два объекта для представления логических значений: true — для истинного значения и false — для ложного. (Все остальные значения, кроме false и nil, рассматриваются как истинные);
числа
в языке могут использоваться числа разных типов. По умолчанию для представления целых чисел используются классы, унаследованные от java.lang.Number — Integer, BigInteger, BigDecimal, но в Clojure реализуется специальный подход, который позволяет представлять число наиболее эффективным способом, автоматически преобразуя числа в случае необходимости — например, при переполнении числа. Если вы хотите для целого числа явно указать тип BigDecimal, то вы можете добавить букву M после значения.
Для чисел с плавающей точкой используется стандартный класс Double.
Кроме этих видов чисел, в Clojure определен специальный тип Ratio, представляющий числа в виде рациональных дробей, что позволяет избегать ошибок округления — например, при делении.
строки
строки в Clojure являются экземплярами класса java.lang.String и к ним можно применять различные функции определенные в этом классе. Форма записи строк Clojure совпадает со стандартной записью строк в Java;
знаки (characters)
являются экземплярами класса java.lang.Character и записываются либо в форме \N, где N — соответствующая буква, либо как названия для неотображаемых букв — например, как \tab и \space для символа табуляции и пробела и т.д.;
символы (symbols)
используются для ссылки на что-то — параметры функций, имена классов, глобальные переменные и т.д. Для представления символа как отдельного объекта, а не как значения, для которого он используется в качестве имени, используется стандартная запись 'symbol (или специальная форма quote);
keywords (ключевые символы)
это специальные символы, имеющие значение самих себя3, аналогично символам (symbols) в Lisp и Ruby. Одним из важных их свойств является очень быстрая операция проверки на равенство, поскольку происходит проверка на равенство указателей. Это свойство делает их очень удобными для использования в качестве ключей в отображениях (maps) и тому подобных вещах. Для именованных аргументов существует специальная форма записи :keyword.
Объявление и связывание символов

Общая форма объявления "динамического" символа выглядит как (def имя значение?), при этом значение может не указываться и тогда символ будет несвязанным со значением. Существуют разные макросы для объявления символов, которые выполняют определенные задачи, например, defonce позволяет объявить символ только один раз, и если он уже имеет значение, то новое значение будет проигнорировано. А с помощью макроса declare можно выполнить опережающее определение (forward declaration) символа — это часто удобно при объявлении взаимно рекурсивных функций. При объявлении символа можно указать метаданные, связанные с данным символом.
Для объявления "лексических" символов используется форма let, которая выглядит следующим образом: (let [имя1 знач1 имя2 знач2 ....] код). 
Например, выполнение следующего кода:
(let [x 1
      y 2]
   (+ x y))
выдаст значение 3. В этом случае переменные x и y видны только внутри формы (+ x y), и возможно маскируют значения переменных, объявленных на глобальном уровне, или выше по коду.
В некоторых случаях, программист может переопределить значение "динамического" символа для конкретного потока выполнения. Это делается с помощью макроса binding, который переопределяет значение указанного символа для данного потока выполнения и всех вызываемых из него функций. 
Например:
user> (def x 10)
user> (def y 20)
user> (defn test-fn []
            (+ x y))
user> (test-fn)
30
user> (binding [x 11
                y 22]
         (test-fn))
33
user> (let [x 11
            y 22]
         (test-fn))
30

В данном коде, если мы выполним test-fn на верхнем уровне кода, то получим значение 30, равное сумме значений переменных x и y. А если эта функция будет вызвана из binding, то мы получим значение 33, равное сумме переменных объявленных в binding. Данные значения изменяются только для текущего потока выполнения, и только для кода, который будет вызван из binding. После завершения выполнения кода в этой форме все предыдущие значения восстанавливаются. А при использовании let значения x и y не воздействуют на функцию test-fn, и в ней используются "глобальные" значения, давая в результате 30.
